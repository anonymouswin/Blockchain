/********************************************************************
|  ***** Coin Contract MVTO Miner + Decentralized validator  *****  |
|  *****     File:   fine.cpp                                *****  |
|  *****  Created:   on Aug 18, 2018, 12:46 AM               *****  |
*********************************************************************
|  *****  COMPILE:: g++ fine.cpp -pthread -std=c++14 -ltbb   *****  |
********************************************************************/

#include <iostream>
#include <thread>
#include "Util/Timer.cpp"
#include "Contract/Coin.cpp"
#include "Graph/Fine/Graph.cpp"
#include "Util/FILEOPR.cpp"

#define MAX_THREADS 128
#define M_SharedObj 5000
#define FUN_IN_CONT 3
#define pl "=============================\n"

using namespace std;
using namespace std::chrono;

int    SObj    = 2;        //! SObj: number of shared objects; at least 2, to send & recive.
int    nThread = 1;        //! nThread: total number of concurrent threads; default is 1.
int    numAUs;             //! numAUs: total number of Atomic Unites to be executed.
double lemda;              //! λ: random delay seed.
double tTime[2];           //! total time taken by miner and validator algorithm.
Coin   *coin;              //! smart contract.
Graph  *cGraph;            //! conflict grpah generated by miner to be given to validator.
int    *aCount;            //! aborted transaction count.
float_t*mTTime;            //! time taken by each miner Thread to execute AUs (Transactions).
float_t*vTTime;            //! time taken by each validator Thread to execute AUs (Transactions).
vector<string>listAUs;     //! holds AUs to be executed on smart contract: "listAUs" index+1 represents AU_ID.
std::atomic<int>currAU;    //! used by miner-thread to get index of Atomic Unit to execute.
std::atomic<int>gNodeCount;//! # of valid AU node added in graph (invalid AUs will not be part of the graph & conflict list).
std::atomic<int>eAUCount;  //! used by validator threads to keep track of how many valid AUs executed by validator threads.
std::atomic<int>*mAUT;     //! array to map AUs to Trans id (time stamp); mAUT[index] = TransID, index+1 = AU_ID.

list<double>mItrT;         //! list holds the avg time taken by miner thread for multiple consecutive runs of miner algorithm.
list<double>vItrT;         //! list holds the avg time taken by validator thread for multiple consecutive runs of validator algorithm.


/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!    Class "Miner" CREATE & RUN "n" miner-THREAD CONCURRENTLY           !
!"concMiner()" CALLED BY miner-THREAD TO PERFROM oprs of RESPECTIVE AUs !
! THREAD 0 IS CONSIDERED AS MINTER-THREAD (SMART CONTRACT DEPLOYER)     !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
class Miner
{
	public:
	Miner(int minter_id)
	{
		cGraph     = new Graph();
		
		//! initialize the counter used
		//! to execute the numAUs to 0.
		currAU     = 0;
		
		//! initialize the graph node counter
		//! to 0 (number of AUs added in graph,
		//! invalid AUs are not part of the grpah).
		gNodeCount = 0;

		//! array index location represents
		//! respective thread id.
		mTTime     = new float_t [nThread];
		aCount     = new int [nThread];
		for(int i = 0; i < nThread; i++) 
		{
			mTTime[i] = 0;
			aCount[i] = 0;
		}
		//! id of the contract creater is "minter_id".
		coin = new Coin(SObj, minter_id);
	}

	//!----------------------------------------------------
	//!!!!!!!! MAIN MINER:: CREATE MINER THREADS !!!!!!!!!!
	//!----------------------------------------------------
	void mainMiner()
	{
		Timer Ltimer;
		thread T[nThread];
		int ts, bal = 1000, total = 0;

		//! initialization of account with fixed
		//! ammount; mint() is assume to be serial.
//		cout<<pl<<"SHARED OBJECTS INITIAL STATE\n"
//			<<pl<<"SObj ID | INITIAL STATE\n"<<pl;
		for(int sid = 1; sid <= SObj; sid++) 
		{
			//! 0 is contract deployer.
			while(coin->mint_m(0, sid, bal, &ts) == false)
			{
				aCount[0]++;
			}
//			cout<<"  "+to_string(sid)+"  \t|  "+to_string(bal)+"\n";
			total = total + bal;
		}
//		cout<<pl<<"  SUM   |  "<<total<<"\n"<<pl;

		//!---------------------------------------------------------
		//!!!!!!!!!!    CREATE NTHREAD MINER THREADS      !!!!!!!!!!
		//!---------------------------------------------------------
//		cout<<"!!!!!!!   Fine-Grain Miner Thread Started         !!!!!!\n";
		double start = Ltimer.timeReq(); //! start timer.
		for( int i = 0; i < nThread; i++ )
		{
			T[i] = thread(concMiner, i, numAUs, cGraph);
		}
		for( auto &th : T)
		{
			th.join ( ); //! miner thread join.
		}
		tTime[0] = Ltimer.timeReq() - start; //! end timer.
//		cout<<"!!!!!!!   Fine-Grain Miner Thread Join            !!!!!!\n";


		//! print conflict grpah generated by miner.
//		cGraph->print_grpah();

		//! print the final state of the shared objects.
//		finalState();
	}

	//!--------------------------------------------------------
	//! THE FUNCTION TO BE EXECUTED BY ALL THE MINER THREADS. !
	//!--------------------------------------------------------
	static void concMiner( int t_ID, int numAUs, Graph *cGraph)
	{
		Timer Ttimer;
		
		//! flag is used to add valid AUs in Graph 
		//! (invalid AU: senders does't have 
		//! sufficent balance to send).
		bool flag   = true;
		
		 //! get the current index, and increment it.
		int  curInd = currAU++;
		
		//! statrt clock to get time 
		//! taken by this transaction.
		auto start  = Ttimer._timeStart();

		while(curInd < numAUs)
		{
			//! trns_id of STM_BTO_transaction
			//! that successfully executed this AU.
			int t_stamp;
			
			//! trans_ids with which 
			//! this AU.trans_id is conflicting.
			list<int>conf_list;
			
			//! get the AU to execute, which is of string type.
			istringstream ss(listAUs[curInd]);

			string tmp;
			ss >> tmp; //! AU_ID to Execute.

			int AU_ID = stoi(tmp);

			ss >> tmp; //! Function Name (smart contract).

			if(tmp.compare("get_bal") == 0)
			{
				ss >> tmp; //! get balance of SObj/id.
				int s_id = stoi(tmp);
				int bal  = 0;

				//! get_bal() of smart contract.
				bool v = coin->get_bal_m(s_id, &bal, t_ID, 
												&t_stamp, conf_list);
				while(v == false)  //! execute again if tryCommit fails.
				{
					aCount[t_ID]++;
					v = coin->get_bal_m(s_id, &bal, t_ID,
											&t_stamp, conf_list);
				}
				mAUT[AU_ID-1] = t_stamp;
			}

			if(tmp.compare("send") == 0)
			{
				ss >> tmp;  //! Sender ID.
				int s_id  = stoi(tmp);
				
				ss >> tmp; //! Reciver ID.
				int r_id  = stoi(tmp);

				ss >> tmp; //! Ammount to send.
				int amt   = stoi(tmp);
				
				int v = coin->send_m(t_ID, s_id, r_id, 
										amt, &t_stamp, conf_list);
				while(v != 1 ) //! execute again if tryCommit fails.
				{
					aCount[t_ID]++;
					v = coin->send_m(t_ID, s_id, r_id,
										 amt, &t_stamp, conf_list);
					if(v == -1)
					{
						//! invalid AU: sender does't
						//! have sufficent balance to send.
						flag = false;
						break;                                    
					}
				}
				mAUT[AU_ID-1] = t_stamp;
			}

			//! graph construction for committed AUs.
			if (flag == true)
			{
				//! increase graph node counter (Valid AU executed).
				gNodeCount++;
				//! get respective tran conflict list using lib fun.
				//list<int>conf_list = lib->get_conf(t_stamp);
				
				//!::::::::::::::::::::::::::::::::::
				//! Remove all the time stamps from :
				//! conflict list, added because    :
				//! of initilization and creation   :
				//! of shared object in STM memory. :
				//!::::::::::::::::::::::::::::::::::
				for(int y=1; y<=SObj; y++) conf_list.remove(y);

				//!------------------------------------------
				//! conf_list COME FROM CONTRACT FUN USING  !
				//! PASS BY ARGUMENT OF get_bel() and send()!
				//!------------------------------------------
				//! when AU_ID conflict is empty.
				if(conf_list.begin() == conf_list.end())
				{
					Graph:: Graph_Node *tempRef;
					cGraph->add_node(AU_ID, t_stamp, &tempRef);
				}

				for(auto it = conf_list.begin(); it != conf_list.end(); it++)
				{
					int i = 0;
					//! find the conf_AU_ID in  map table
					//! given conflicting time-stamp.
					while(*it != mAUT[i])
					i = (i+1)%numAUs; 

					//! because array index start
					//! with 0 and index+1 respresent AU_ID.
					int cAUID   = i+1;
					int cTstamp = mAUT[i];//! conflicting AU_ID with this.AU_ID.
					
					if(cTstamp  < t_stamp) //! edge from conf_AU_ID to AU_ID.
					cGraph->add_edge(cAUID, AU_ID, cTstamp, t_stamp);
					
					if(cTstamp > t_stamp)  //! edge from AU_ID to conf_AU_ID.
					cGraph->add_edge(AU_ID, cAUID, t_stamp, cTstamp);
				}
			}
			flag   = true; //! reset flag for next AU.
			
			//! get the current index
			//! to execute, and increment it.
			curInd = currAU++;
		}

		mTTime[t_ID] = mTTime[t_ID] + Ttimer._timeStop( start );
	}

	//!-------------------------------------------------
	//!FINAL STATE OF ALL THE SHARED OBJECT. Once all  |
	//!AUs executed. we are geting this using get_bel()|
	//!-------------------------------------------------
	void finalState()
	{
		list<int>cList;	int total = 0;
//		cout<<pl<<"SHARED OBJECTS FINAL STATE\n"
//			<<pl<<"SObj ID | FINAL STATE\n"<<pl;
		for(int sid = 1; sid <= SObj; sid++) 
		{
			int bal = 0, ts;
			//! get_bal() of smart contract, execute again if tryCommit fails.
			while(coin->get_bal_m(sid, &bal, 0, &ts, cList) == false )
			{
				
			}
//			cout<<"  "+to_string(sid)+"  \t|  "+to_string(bal)+"\n";
			total = total + bal;
		}
//		cout<<pl<<"  SUM   |  "<<total<<"\n"<<pl;
//		cout<<"\n Number of Valid   AUs = "+to_string(gNodeCount)
//			+" (Grpah Nodes:: AUs Executed Successfully)\n";
//		cout<<" Number of Invalid AUs = "+to_string(numAUs-gNodeCount)+"\n";
	}
	~Miner() { };
};


/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Class "Validator" CREATE & RUN "n" validator-THREAD   !
! CONCURRENTLY BASED ON CONFLICT GRPAH GIVEN BY MINER.  !
! "concValidator()" CALLED BY validator-THREAD TO       !
! PERFROM OPERATIONS of RESPECTIVE AUs.  THREAD 0 IS    !
! CONSIDERED AS MINTER-THREAD (SMART CONTRACT DEPLOYER) !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
class Validator
{
public:
	Validator()
	{
		eAUCount = 0;
		//! array index location represents respective thread id.
		vTTime   = new float_t[nThread];
		for(int i = 0; i < nThread; i++) vTTime[i] = 0;
	};

	/*!---------------------------------------
	| CREATE N CONCURRENT VALIDATOR THREADS  |
	| TO EXECUTE VALID AUS IN CONFLICT GRAPH.|
	----------------------------------------*/
	void mainValidator()
	{
		Timer Ttimer;
		int bal = 1000, total = 0;
		thread T[nThread];
		//! initialization of account with fixed ammount;
		//! mint_val() function is assume to be serial.
		for(int sid = 1; sid <= SObj; sid++) 
		{
			bool r = coin->mint(0, sid, bal);//! 0 is contract deployer.
			total  = total + bal;
		}

		//!Create "nThread" threads
//		cout<<"!!!!!!!   Fine-Grain Validator Thread Started     !!!!!!\n";
		double start = Ttimer.timeReq(); //! start timer
		
		for(int i = 0; i < nThread; i++)
		{
			T[i] = thread(concValidator, i);
		}
		for(auto& th : T) 
		{
			th.join ( );
		}
		tTime[1] = Ttimer.timeReq() - start; //! stop timer.
//		cout<<"!!!!!!!   Fine-Grain Validator Thread Join        !!!!!!\n\n";

		//! print the final state of the
		//! shared objects by validator.
//		finalState();
	}

	//!--------------------------------------------------------
	//! THE FUNCTION TO BE EXECUTED BY ALL VALIDATOR THREADS. !
	//!--------------------------------------------------------
	static void concValidator( int t_ID )
	{
		Timer Ttimer;
		//! start timer to get time taken by this thread.
		auto start = Ttimer._timeStart();

		list<Graph::Graph_Node*>buffer;
		auto itr = buffer.begin();

		Graph:: Graph_Node *verTemp;
		while( true )
		{
			//! uncomment this to remove the 
			//! effect of local buffer optimization.
			//buffer.clear();

			//! all Graph Nodes (Valid AUs executed)
			if(eAUCount == gNodeCount )
				break;
			//!-----------------------------------------
			//!!!<< AU execution from local buffer. >>!!
			//!-----------------------------------------
			for(itr = buffer.begin(); itr != buffer.end(); itr++)
			{
				Graph::Graph_Node* temp = *itr;
				if(temp->in_count == 0)
				{
					temp->nodeLock.lock();
					if(temp->marked == false ) //! unclaimed unexecuted AU.
					{
						temp->marked   = true; //! AU claimed by this.t_ID.
						
						temp->in_count = -1;

						eAUCount++;//! num of Valid AUs executed is eAUCount+1
						
						//! relase lock X1 either
						//! here or in last else condition
						temp->nodeLock.unlock();

						//! get the AU to execute, which is 
						//! of string type; listAUs index statrt with 0
						istringstream ss( listAUs[(temp->AU_ID) -1 ]);
						string tmp;

						ss >> tmp;  //! AU_ID to Execute
						int AU_ID = stoi(tmp);

						ss >> tmp; //! Function Name (smart contract)
						if(tmp.compare("get_bal") == 0)
						{
							ss >> tmp;//! get balance of SObj/id
							int s_id = stoi(tmp);
							int bal  = 0;

							//! get_bal() of smart contract.
							bool v = coin->get_bal(s_id, &bal);
						}
						if( tmp.compare("send") == 0 )
						{
							ss >> tmp; //! Sender ID.
							int s_id = stoi(tmp);
							ss >> tmp;  //! Reciver ID.
							int r_id = stoi(tmp);
							ss >> tmp; //! Ammount to send.
							int amt  = stoi(tmp);
							bool v   = coin->send(s_id, r_id, amt);
						}

						Graph::EdgeNode *e_temp = temp->edgeHead->next;
						while( e_temp != temp->edgeTail)
						{
							Graph::Graph_Node* refVN = 
											(Graph::Graph_Node*)e_temp->ref;
							refVN->in_count--;
							//! insert into local buffer.
							if(refVN->in_count == 0 )
								buffer.push_back(refVN);

							e_temp = e_temp->next;
						}
					}
					else
						temp->nodeLock.unlock();
				}
			}
			//! reached to end of local
			//! buffer; clear the buffer.
			buffer.clear();

			//!-----------------------------------------------------
			//!!!<< AU execution by traversing conflict grpah  >>!!!
			//!-----------------------------------------------------
			verTemp = cGraph->verHead->next;
			while(verTemp != cGraph->verTail)
			{
				if(verTemp->in_count == 0)
				{
					verTemp->nodeLock.lock(); //! get lock X1.
					if(verTemp->marked == false ) //! unclaimed unexecuted AU.
					{
						verTemp->marked   = true; //! AU claimed by this.t_ID.

						verTemp->in_count = -1;

						//! relase lock X1 either here
						//! or in last else condition.
						verTemp->nodeLock.unlock();
						eAUCount++;//! num of Valid AUs executed is eAUCount+1.


						//! get the AU to execute, 
						//! which is of string type;
						//! listAUs index statrt with 0.
						istringstream ss(listAUs[(verTemp->AU_ID)-1]);
						string tmp;

						ss >> tmp;//! AU_ID to Execute.
						int AU_ID = stoi(tmp);

						ss >> tmp;//! Function Name (smart contract).
						if(tmp.compare("get_bal") == 0)
						{
							ss >> tmp; //! get balance of SObj/id.
							int s_id = stoi(tmp);
							int bal  = 0;
							bool v   = coin->get_bal(s_id, &bal);
						}
						if( tmp.compare("send") == 0 )
						{
							ss >> tmp;//! Sender ID.
							int s_id = stoi(tmp);
							ss >> tmp;//! Reciver ID.
							int r_id = stoi(tmp);
							ss >> tmp;//! Ammount to send.
							int amt  = stoi(tmp);
							bool v   = coin->send(s_id, r_id, amt);
						}

						//!-----------------------------------------
						//!CHANGE INDEGREE OF OUT EDGE NODES (NODE !
						//! HAVING INCOMMING EDGE FROM THIS NODE). !
						//!-----------------------------------------
						Graph::EdgeNode *e_temp = verTemp->edgeHead->next;

						while( e_temp != verTemp->edgeTail)
						{
							Graph::Graph_Node* refVN = 
											(Graph::Graph_Node*)e_temp->ref;
							refVN->in_count--;
							//! insert into local buffer.
							if(refVN->in_count == 0 )
								buffer.push_back(refVN);
								
							e_temp = e_temp->next;
						}
					}
					else
						verTemp->nodeLock.unlock(); //! or relase lock X1 here.
				}
				verTemp = verTemp->next;
			}
		}

		vTTime[t_ID] = vTTime[t_ID] + Ttimer._timeStop( start );
	}

	//!-------------------------------------------------
	//!FINAL STATE OF ALL THE SHARED OBJECT. ONCE ALL  |
	//!AUS EXECUTED. GETING THIS USING get_bel_val()   |
	//!-------------------------------------------------
	void finalState()
	{
		int total = 0;
//		cout<<pl<<"SHARED OBJECTS FINAL STATE\n"
//			<<pl<<"SObj ID | FINAL STATE\n"<<pl;
		for(int sid = 1; sid <= SObj; sid++) 
		{
			int bal = 0, ts;
			bool v  = coin->get_bal(sid, &bal);
			total   = total + bal;
//			cout<<"  "+to_string(sid)+"  \t|  "+to_string(bal)+"\n";
		}
//		cout<<pl<<"  SUM   |  "<<total<<"\n"<<pl;
	}

	~Validator() { };
};




/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
/*!!!!!!!!!!!!!!!   main() !!!!!!!!!!!!!!!!!!*/
/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
int main( )
{
	//! list holds the avg time taken
	//! by miner and Validator threads
	//! for multiple consecutive runs.
	list<double>mItrT;
	list<double>vItrT;

	FILEOPR file_opr;

	//! read from input file:: SObj = #SObj; nThread = #threads;
	//! numAUs = #AUs; λ = random delay seed.
	file_opr.getInp(&SObj, &nThread, &numAUs, &lemda);

	//! max shared object error handling.
	if(SObj > M_SharedObj) 
	{
		SObj = M_SharedObj;
		cout<<"Max number of Shared Object can be "<<M_SharedObj<<"\n";
	}

	cout<<pl<<" Fine Grain Algorithm \n"<<pl;
	int totalRun = 1;
	for(int numItr = 0; numItr < totalRun; numItr++)
	{
		//! generates AUs (i.e. trans to be executed by miner & validator).
		file_opr.genAUs(numAUs, SObj, FUN_IN_CONT, listAUs);

		//! index+1 represents respective AU id, and
		//! mAUT[index] represents "time stamp (commited trans)".
		mAUT = new std::atomic<int>[numAUs];
		for(int i = 0; i< numAUs; i++)
		{
			mAUT[i] = 0;
		}
		Timer mTimer;
		mTimer.start();

		//MINER
		Miner *miner = new Miner(0);
		miner ->mainMiner();

		//VALIDATOR
		Validator *validator = new Validator();
		validator ->mainValidator();

		mTimer.stop();

		//! total valid AUs among total AUs executed
		//! by miner and varified by Validator.
		int vAUs = gNodeCount;
		file_opr.writeOpt(SObj, nThread, numAUs, tTime,
							mTTime, vTTime, aCount, vAUs, mItrT, vItrT);
		cout<<"\n===================== Execution "<<numItr+1
			<<" Over =====================\n"<<endl;
		listAUs.clear();
		delete miner;
		miner = NULL;
		delete cGraph;
		cGraph = NULL;
		delete validator;
		validator = NULL;
		delete validator;
	}
	//! to get total avg miner and validator
	//! time after number of totalRun runs.
	double tAvgMinerT = 0, tAvgValidT = 0;
	auto mit = mItrT.begin();
	auto vit = vItrT.begin();
	for(int j = 0; j < totalRun; j++)
	{
		tAvgMinerT = tAvgMinerT + *mit;
//		cout<<"\n    Avg Miner = "<<*mit;
		tAvgValidT = tAvgValidT + *vit;
//		cout<<"\nAvg Validator = "<<*vit;
		mit++;
		vit++;
	}
	tAvgMinerT = tAvgMinerT/totalRun;
	tAvgValidT = tAvgValidT/totalRun;
	cout<<pl<<"    Total Avg Miner = "<<tAvgMinerT<<" microseconds";
	cout<<"\nTotal Avg Validator = "<<tAvgValidT<<" microseconds";
	cout<<"\n  Total Avg (M + V) = "<<tAvgMinerT+tAvgValidT<<" microseconds";
	cout<<"\n"<<pl;
return 0;
}
