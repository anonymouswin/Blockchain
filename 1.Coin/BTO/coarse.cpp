/********************************************************************
|  ***** Coin Contract BTO Miner + Decentralized validator   *****  |
|  *****     File:   coarse.cpp                              *****  |
|  *****  Created:   Aug 18, 2018, 15:00 PM                  *****  |
*********************************************************************
|  *****  COMPILE:: g++ coarse.cpp -pthread -std=c++14 -ltbb *****  |
********************************************************************/

#include <iostream>
#include <thread>
#include "Util/Timer.cpp"
#include "Contract/Coin.cpp"
#include "Graph/Coarse/Graph.cpp"
#include "Util/FILEOPR.cpp"

#define MAX_THREADS 128
#define M_SharedObj 5000
#define FUN_IN_CONT 3
#define pl "=============================\n"

using namespace std;
using namespace std::chrono;

int    SObj    = 2;        //! SObj: number of shared objects; at least 2, to send & recive.
int    nThread = 1;        //! nThread: total number of concurrent threads; default is 1.
int    numAUs;             //! numAUs: total number of Atomic Unites to be executed.
double lemda;              //! Î»: random delay seed.
double tTime[2];           //! total time taken by miner and validator algorithm.
Coin   *coin;              //! smart contract.
Graph  *cGraph;            //! conflict grpah generated by miner to be given to validator.
float_t *gTtime;           //! time taken by each miner Thread to add edges and nodes in the conflict graph.
int    *aCount;            //! aborted transaction count.
float_t*mTTime;            //! time taken by each miner Thread to execute AUs (Transactions).
float_t*vTTime;            //! time taken by each validator Thread to execute AUs (Transactions).
vector<string>listAUs;     //! holds AUs to be executed on smart contract: "listAUs" index+1 represents AU_ID.
std::atomic<int>currAU;    //! used by miner-thread to get index of Atomic Unit to execute.
std::atomic<int>gNodeCount;//! # of valid AU node added in graph (invalid AUs will not be part of the graph & conflict list).
std::atomic<int>eAUCount;  //! used by validator threads to keep track of how many valid AUs executed by validator threads.
std::atomic<int>*mAUT;     //! array to map AUs to Trans id (time stamp); mAUT[index] = TransID, index+1 = AU_ID.



/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!    Class "Miner" CREATE & RUN "n" miner-THREAD CONCURRENTLY           !
!"concMiner()" CALLED BY miner-THREAD TO PERFROM oprs of RESPECTIVE AUs !
! THREAD 0 IS CONSIDERED AS MINTER-THREAD (SMART CONTRACT DEPLOYER)     !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
class Miner
{
	public:
	Miner(int minter_id)
	{
		cGraph = new Graph();

		//! initialize the counter used to execute the numAUs to.
		//! 0, and graph node counter to 0 (number of AUs added.
		//! in graph, invalid AUs will not part be of the grpah).
		currAU     = 0;
		gNodeCount = 0;

		//! index location represents respective thread id.
		mTTime = new float_t [nThread];
		gTtime = new float_t [nThread];
		aCount = new int [nThread];
		
		for(int i = 0; i < nThread; i++) 
		{
			mTTime[i] = 0;
			gTtime[i] = 0;
			aCount[i] = 0;
		}
		//! id of the contract creater is "minter_id".
		coin = new Coin( SObj, minter_id );
	}

	//!-------------------------------------------- 
	//!!!!!! MAIN MINER:: CREATE MINER THREADS !!!!
	//!--------------------------------------------
	void mainMiner()
	{
		Timer mTimer;
		thread T[nThread];

		//! initialization of account with
		//! fixed ammount; mint_m() is serial.
		int ts, bal = 1000, total = 0;
	for(int sid = 1; sid <= SObj; sid++) 
		{
			//! 0 is contract deployer.
			coin->mint_m(0, sid, bal, &ts);
		}

		//!------------------------------------------
		//!!!!!! CREATE nThreads MINER THREADS  !!!!!
		//!------------------------------------------
		//! Start clock.
		double start = mTimer.timeReq();
		for(int i = 0; i < nThread; i++)
		{
			T[i] = thread(concMiner, i, numAUs, cGraph);
		}
		//! miner thread join
		for(auto& th : T)
		{
			th.join();
		}
		//! Stop clock.
		tTime[0] = mTimer.timeReq() - start;


		//! print conflict grpah.
//		cGraph->print_grpah();

		//! print the final state
		//! of the shared objects.
//		finalState();
//		cout<<"\n Number of Valid   AUs = "+to_string(gNodeCount)
//				+" (Grpah Nodes:: AUs Executed Successfully)\n";
//		cout<<" Number of Invalid AUs = "+to_string(numAUs-gNodeCount)+"\n";
	}

	//!--------------------------------------------------------
	//! THE FUNCTION TO BE EXECUTED BY ALL THE MINER THREADS. !
	//!--------------------------------------------------------
	static void concMiner( int t_ID, int numAUs, Graph *cGraph)
	{
		Timer thTimer;

		//! flag is used to add valid AUs in Graph.
		//! (invalid AU: senders doesn't
		//! have sufficient balance to send).
		bool flag = true;

		//! get the current index, and increment it.
		int curInd = currAU++;

		//! statrt clock to get time taken by this.AU
		auto start = thTimer._timeStart();

		while( curInd < numAUs )
		{
			//! trns_id of STM_BTO_trans that
			//! successfully executed this AU.
			int t_stamp;

			//! trans_ids with which 
			//! this AU.trans_id is conflicting.
			list<int>conf_list;

			//! get the AU to execute,
			//! which is of string type.
			istringstream ss(listAUs[curInd]);

			string tmp;
			//! AU_ID to Execute.
			ss >> tmp;

			int AU_ID = stoi(tmp);

			//! Function Name (smart contract).
			ss >> tmp;

			if(tmp.compare("get_bal") == 0)
			{
				//! get balance of SObj/id.
				ss >> tmp;
				int s_id = stoi(tmp);
				int bal  = 0;

				//! get_bal of smart contract::
				//! execute again if tryCommit fails.
				while(coin->get_bal_m(s_id, &bal, t_ID, 
										&t_stamp, conf_list) == false)
				{
					aCount[t_ID]++;
				}
				mAUT[AU_ID-1] = t_stamp;
			}

			if(tmp.compare("send") == 0)
			{
				//! Sender ID
				ss >> tmp;
				int s_id = stoi(tmp);

				//! Reciver ID
				ss >> tmp;
				int r_id = stoi(tmp);

				//! Ammount to send
				ss >> tmp;
				int amt  = stoi(tmp);
				int v = coin->send_m(t_ID, s_id, r_id, amt,
										 &t_stamp, conf_list);
				//! execute again if tryCommit fails
				while(v != 1 )
				{
					aCount[t_ID]++;
					v = coin->send_m(t_ID, s_id, r_id, 
										amt, &t_stamp, conf_list);
					if(v == -1)
					{
						//! invalid AU:sender does'
						//! t have sufficent bal to send.
						flag = false;
						break;                                    
					}
				}
				mAUT[AU_ID-1] = t_stamp;
			}
			//! increase graph node
			//! counter (Valid AU executed)
			if (flag == true) 
			{
				gNodeCount++;
				//! get respective trans 
				//! conflict list using lib fun.
				//list<int>conf_list = lib->get_conf(t_stamp);
				
				//!::::::::::::::::::::::::::::::::::
				//! Remove all the time stamps from :
				//! conflict list, added because    :
				//! of initilization and creation   :
				//! of shared object in STM memory. :
				//!::::::::::::::::::::::::::::::::::
				for(int y = 1; y <= SObj; y++) conf_list.remove(y);
			
				//! statrt clock to get time taken by this.thread 
				//! to add edges and node to conflict grpah.
				auto gstart = thTimer._timeStart();
				
				//! if AU_ID conflict is empty,
				//! add node this AU_ID vertex node.
				if(conf_list.begin() == conf_list.end())
				{
					cGraph->gLock.lock();
					Graph::Graph_Node *tempRef;
					cGraph->add_node(AU_ID, t_stamp, &tempRef);
					cGraph->gLock.unlock();
				}
				for(auto it = conf_list.begin(); it != conf_list.end(); it++)
				{
					int i = 0;
					//! get conf AU_ID in map
					//! table given conflicting tStamp.
					while(*it != mAUT[i]) i = (i+1)%numAUs;

					//! index start with 0 =>
					//! index+1 respresent AU_ID.
					//! cAUID = index+1, cTstamp
					//! = mAUT[i] with this.AU_ID.
					int cAUID   = i+1;
					int cTstamp = mAUT[i];

					if(cTstamp < t_stamp)
					{
						cGraph->gLock.lock();
						//! edge from cAUID to AU_ID.
						cGraph->add_edge(cAUID, AU_ID, cTstamp, t_stamp);
						cGraph->gLock.unlock();
					}
					if(cTstamp > t_stamp) 
					{
						cGraph->gLock.lock();
						//! edge from AU_ID to cAUID.
						cGraph->add_edge(AU_ID, cAUID, t_stamp, cTstamp);
						cGraph->gLock.unlock();
					}
				}
				gTtime[t_ID] = gTtime[t_ID] + thTimer._timeStop(gstart);
			}
			//! reset flag for next AU.
			flag = true;
			
			//! get the current index to
			//! execute, and increment it.
			curInd = currAU++;
			conf_list.clear();
		}
		mTTime[t_ID] = mTTime[t_ID] + thTimer._timeStop(start);
	}


	//!-------------------------------------------------
	//!FINAL STATE OF ALL THE SHARED OBJECT. ONCE ALL  |
	//!AUS EXECUTED. WE ARE GETING THIS USING get_bel()|
	//!-------------------------------------------------
	void finalState()
	{
		list<int>cList;	int total = 0;
		cout<<pl<<"SHARED OBJECTS FINAL STATE\n"
			<<pl<<"SObj ID | FINAL STATE\n"<<pl;
		for(int sid = 1; sid <= SObj; sid++) 
		{
			int bal = 0, ts;
			//! get_bal_m() of smart contract, 
			//! execute again if tryCommit fails.
			while( coin->get_bal_m(sid, &bal, 0, 
									&ts, cList) == false ) {}
		
			cout<<"  "+to_string(sid)+"  \t|  "+to_string(bal)+"\n";
			total = total + bal;
			cList.clear();
		}
		cout<<pl<<"  SUM   |  "<<total<<"\n"<<pl;
	}

	~Miner() { };
};


/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Class "Validator" CREATE & RUN "n" validator-THREAD   !
! CONCURRENTLY BASED ON CONFLICT GRPAH GIVEN BY MINER.  !
! "concValidator()" CALLED BY validator-THREAD TO       !
! PERFROM OPERATIONS of RESPECTIVE AUs.  THREAD 0 IS    !
! CONSIDERED AS MINTER-THREAD (SMART CONTRACT DEPLOYER) !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
class Validator
{
public:

	Validator()
	{
		//! int the execution counter
		//! used by validator threads.
		eAUCount = 0;
		
		//! array index => respective thread id.
		vTTime = new float_t [nThread];
		for(int i = 0; i < nThread; i++)
		{ 
			vTTime[i] = 0;
		}
	};

	/*!---------------------------------------
	| CREATE N CONCURRENT VALIDATOR THREADS  |
	| TO EXECUTE VALID AUS IN CONFLICT GRAPH.|
	----------------------------------------*/
	void mainValidator()
	{
		Timer vTimer;
		thread T[nThread];

		//! initialization of account with fixed
		//! ammount; mint_val() function is serial.
		int bal = 1000, total = 0;
		for(int sid = 1; sid <= SObj; sid++) 
		{
			//! 0 is contract deployer.
			bool v = coin->mint(0, sid, bal);
			total  = total + bal;
		}

		//!-------------------------------------------
		//!!!!! CREATE nThreads VALIDATOR THREAD  !!!!
		//!-------------------------------------------
//		cout<<"!! Coarse-Grain Validator Thread Started  !!\n";
		//! Start clock.
		double start = vTimer.timeReq();
		for(int i = 0; i<nThread; i++)
		{
			T[i] = thread(concValidator, i);
		}
		//! validator thread join.
		for(auto& th : T)
		{
			th.join( );
		}
		//! Stop clock.
		tTime[1] = vTimer.timeReq() - start;
//		cout<<"!! Coarse-Grain Validator Thread Join  !!\n";

		//!print the final state of the shared objects by validator.
//		finalState();
	}


	//!-------------------------------------------------------
	//! FUNCTION TO BE EXECUTED BY ALL THE VALIDATOR THREADS.!
	//!-------------------------------------------------------
	static void concValidator( int t_ID )
	{
		Timer thTimer;

		//!statrt clock to get time taken by this thread.
		auto start = thTimer._timeStart();
		
		list<Graph::Graph_Node*>buffer;
		auto itr = buffer.begin();

		Graph::Graph_Node *verTemp;
		while( true )
		{
			//! uncomment this to remove effect
			//! of local buffer optimization.
//			buffer.clear();

			//! all Graph Nodes (Valid AUs executed).
			if(eAUCount == gNodeCount ) break;
			
			//!-----------------------------------------
			//!!!<< AU EXECUTION FROM LOCAL BUFFER. >>!!
			//!-----------------------------------------
			for(itr = buffer.begin(); itr != buffer.end(); itr++)
			{
				Graph::Graph_Node* temp = *itr;
				if(temp->in_count == 0)
				{
					//! get lock X1.
					cGraph->gLock.lock();

					//! AU is unclaimed if in_count ==> 0
					//! unexecuted if marked ==> false.
					if(temp->marked == false )
					{
						//! AU claimed by this.t_ID
						temp->marked = true;

						//! logical delete, node 
						//! will not be executed
						//! again::even marked
						//! field is logical delete.
						temp->in_count = -1;

						//! num of Valid AUs
						//! executed is eAUCount+1.
						eAUCount++;

						//! relase lock X1 either
						//! here or in else part.
						cGraph->gLock.unlock();

						//! get AU to execute,
						//! which is of string type;
						//! listAUs index statrt
						//! with 0 ==> -1.
						istringstream ss( listAUs[(temp->AU_ID) - 1]);
						string tmp;

						//! AU_ID to Execute.
						ss >> tmp;
						int AU_ID = stoi(tmp);


						//! Function Name (smart contract).
						ss >> tmp;
						if( tmp.compare("get_bal") == 0 )
						{
							//! get balance of SObj/id.
							ss >> tmp;
							int s_id = stoi(tmp);
							int bal  = 0;

							//! get_bal() of smart contract.
							bool v = coin->get_bal(s_id, &bal);
						}
						if( tmp.compare("send") == 0 )
						{
							//! Sender ID.
							ss >> tmp;
							int s_id = stoi(tmp);

							//! Reciver ID.
							ss >> tmp;
							int r_id = stoi(tmp);

							//! Ammount to Send.
							ss >> tmp;
							int amt = stoi(tmp);
							bool v  = coin->send(s_id, r_id, amt);
						}

						Graph::EdgeNode *eTemp = temp->edgeHead->next;
						while( eTemp != temp->edgeTail)
						{
							Graph::Graph_Node* refVN =
											(Graph::Graph_Node*)eTemp->ref;

							refVN->in_count--;
							if(refVN->in_count == 0 )
							{
								//! insert into local buffer.
								buffer.push_back(refVN);
							}
							eTemp = eTemp->next;
						}
						delete eTemp;
					}
					else
					{
						cGraph->gLock.unlock();
					}
				}
			}
			//! reached to end of local
			//! buffer; clear the buffer.
			buffer.clear();

			//!-----------------------------------------------------
			//!!!<< AU EXECUTION BY TRAVERSING CONFLICT GRPAH  >>!!!
			//!-----------------------------------------------------
			verTemp = cGraph->verHead->next;
			while(verTemp != cGraph->verTail)
			{
				if(verTemp->in_count == 0)
				{
					//! get lock X1.
					cGraph->gLock.lock();

					//! unclaimed unexecuted AU.
					if(verTemp->marked == false )
					{
						//! AU claimed by this.t_ID
						verTemp->marked   = true;

						//! this node will not
						//! be executed again::
						//! marked field/in_count
						//! is logical delete.
						verTemp->in_count = -1;

						//! num of Valid AUs
						//! executed is eAUCount+1.
						eAUCount++;

						//! relase lock X1 either here
						//! or at else condition at end.
						cGraph->gLock.unlock();

						//! get AU to execute,
						//! which is of string type;
						//! listAUs index 
						//! statrt with 0 => -1.
						istringstream ss(listAUs[(verTemp->AU_ID)-1]);
						string tmp;

						//! AU_ID to Execute.
						ss >> tmp;
						int AU_ID = stoi(tmp);

						//! Function Name (smart contract).
						ss >> tmp;
						if( tmp.compare("get_bal") == 0 )
						{
							//! get balance of SObj/id.
							ss >> tmp;
							int s_id = stoi(tmp);
							int bal  = 0;

							//! get_bal() of smart contract.
							bool v = coin->get_bal(s_id, &bal);
						}
						if( tmp.compare("send") == 0 )
						{
							//! Sender ID.
							ss >> tmp;
							int s_id = stoi(tmp);

							//! Reciver ID.
							ss >> tmp;
							int r_id = stoi(tmp);

							//! Ammount to send.
							ss >> tmp;
							int amt  = stoi(tmp);
							bool v   = coin->send(s_id, r_id, amt);
						}
						Graph::EdgeNode *eTemp = verTemp->edgeHead->next;
						while( eTemp != verTemp->edgeTail)
						{
							Graph::Graph_Node* refVN =
										(Graph::Graph_Node*)eTemp->ref;

							refVN->in_count--;
							
							if(refVN->in_count == 0 )
							{
								//! insert into local buffer.
								buffer.push_back( refVN );
							}
							eTemp = eTemp->next;
						}
					}
					//! or relase lock X1 here.
					else
					{
						cGraph->gLock.unlock();
					}
				}
				verTemp = verTemp->next;
			}
		}
		verTemp = NULL;
		delete verTemp;
		buffer.clear();
		vTTime[t_ID] = vTTime[t_ID] + thTimer._timeStop(start);
	}


	//!-------------------------------------------------
	//!FINAL STATE OF ALL THE SHARED OBJECT. Once all  |
	//!AUs executed. Geting this using get_bel_val()   |
	//!-------------------------------------------------
	void finalState()
	{
		int total = 0;
		cout<<pl<<"SHARED OBJECTS FINAL STATE\n"
			<<pl<<"SObj ID | FINAL STATE\n"<<pl;
		for(int sid = 1; sid <= SObj; sid++) 
		{
			int bal = 0;
			//! get_bal() of smart contract.
			bool v = coin->get_bal(sid, &bal);
			total  = total + bal;
			cout<<"  "+to_string(sid)+"  \t|  "+to_string(bal)+"\n";
		}
		cout<<pl<<"  SUM   |  "<<total<<"\n"<<pl;
	}

	~Validator() { };
};




/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
/*!!!!!!!!!!!!!!!   main() !!!!!!!!!!!!!!!!!!*/
/*!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
int main( )
{
	//! list holds the avg time
	//! taken by miner and Validator
	//! thread s for multiple consecutive runs.
	list<double>mItrT;
	list<double>vItrT;

	FILEOPR file_opr;
	//! read from input file :: SObj
	//! = #SObj; nThread = #threads;
	//! numAUs = #AUs; Î» = random delay seed.
	file_opr.getInp(&SObj, &nThread, &numAUs, &lemda);
	//! max shared object error handling.
	if(SObj > M_SharedObj) 
	{
		SObj = M_SharedObj;
		cout<<"Max number of Shared Object can be "<<M_SharedObj<<"\n";
	}

	cout<<pl<<" BTO Coarse Grain Algorithm \n"<<pl;
	int totalRun = 1;
	for(int numItr = 0; numItr < totalRun; numItr++)
	{

		 //! generates AUs (i.e. trans to be
		 //! executed by miner & validator).
		file_opr.genAUs(numAUs, SObj, FUN_IN_CONT, listAUs);

		//! index+1 represents
		//! respective AU id, and
		//! mAUT[index] represents
		//! "time stamp (commited trans)".
		mAUT = new std::atomic<int>[numAUs];
		for(int i = 0; i< numAUs; i++)
		{
			mAUT[i] = 0;
		}
		Timer mTimer;
		mTimer.start();

		//MINER
		Miner *miner = new Miner(0);
		miner ->mainMiner();

		//VALIDATOR
		Validator *validator = new Validator();
		validator ->mainValidator();

		mTimer.stop();

		//! total valid AUs among total AUs executed
		//! by miner and varified by Validator.
		int vAUs = gNodeCount;
		file_opr.writeOpt(SObj, nThread, numAUs, tTime,
							 mTTime, vTTime, aCount, vAUs, mItrT, vItrT);
		cout<<"\n===================== Execution "<<numItr+1
			<<" Over =====================\n"<<endl;

		listAUs.clear();
		delete miner;
		miner = NULL;
		delete cGraph;
		cGraph = NULL;
		delete validator;
		validator = NULL;
	}
	
	//! to get total avg miner and validator
	//! time after number of totalRun runs.
	double tAvgMinerT = 0, tAvgValidT = 0;
	auto mit = mItrT.begin();
	auto vit = vItrT.begin();
	for(int j = 0; j < totalRun; j++)
	{
		tAvgMinerT = tAvgMinerT + *mit;
		tAvgValidT = tAvgValidT + *vit;
		mit++;
		vit++;
	}
	tAvgMinerT = tAvgMinerT/totalRun;
	tAvgValidT = tAvgValidT/totalRun;
	cout<<pl<<"    Total Avg Miner = "<<tAvgMinerT<<" microseconds";
	cout<<"\nTotal Avg Validator = "<<tAvgValidT<<" microseconds";
	cout<<"\n  Total Avg (M + V) = "<<tAvgMinerT+tAvgValidT<<" microseconds";
	cout<<"\n"<<pl;
return 0;
}
